---
title: 移位运算
copyright: true
date: 2019-02-23 10:54:28
tags: [Java,移位运算]
categories: Java
top:
---

#### 对于移位运算符:

1. `<< n` 将数字的二进制左移n位，低位补零，相当于\* 2^n^。
>相当于加上本身，自然1进0，0进1，因为相加的两个数相等，结尾为零。
2. `>> n`右移n位，高位补首位，相当于 \ 2^n^。
>得到的结果与自身相加可以回到原来的数，因为除法会舍去余数，末尾的不管是1和0都会被丢弃。

<!--more-->

```
 5<<2 等于20
        5的二进制是   0000 0000 0000 0101
        左移两位      0000 0000 0001 0100
 5>>2 等于 1
        5的二进制是   0000 0000 0000 0101
        右移两位      0000 0000 0000 0001
-5>>2 等于 -2
       -5的二进制是   1111 1111 1111 1011
        右移两位      1111 1111 1111 1110 
```

3. `>>> n`无符号右移n位，高位只补0。对于正数与`>>`无区别，对于负数，高位补0。

```
-10>>>2
   -10的二进制是 1111 1111 1111 0110
   右移两位      0011 1111 1111 1101
```

如果对char、byte或者short类型的数值进行移位处理，那么在移位进行之前，它们会被转为int类型，并且得到结果也是一个int类型的值，只有数值右端的底5位才有用，这样可防止我们移位超过int类型所具有的位数，（因为2的5次方位为32，而int类型只有32位）。若对一个long类型的数值进行处理，最后得到结果也是long类型，此时只会用到数值右端的底6位，以防止移位超过long类型数值具有的位数。

“移位”可与“等号”（<<=或>>=或>>>=）组合使用。此时，操作符左边的值会移动由右边的值指定的位数，再将得到的结果赋值给左边的变量。但在进行“无符号”右移位结合赋值操作时，可能会遇到一个问题，如果对byte或short值进行这样的移位运算，得到的可能不是正确的结果。他们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。

移位运算符比乘法更高效，因为是直接作用于内存，对于一般的除法，是这样运算的：

```
11/2 = 11- 2 = 9 count=1
     = 9 - 2 = 7 count=2
     = 7 - 2 = 5 count=3
     = 5 - 2 = 3 count=4
     = 3 - 2 = 1 count=5
     = 1 - 2 = -1 <= 0
因此结果为cout=5

```

显然移位运算是比直接的除法高效的。